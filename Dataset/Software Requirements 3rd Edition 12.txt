but makes it clear that the sketches are not the committed screen designs. For example, a preliminary sketch of a complex dialog box will illustrate the intent behind a group of requirements, but a visual designer might turn it into a tabbed dialog box to improve usability.

FIGURE 10-1 Example of a user interface "sketch" suitable for inclusion in a requirements document.

Teams working on projects that have many screens might find it more manageable to document the user interface design specifics in a separate user interface specification or by using UI design tools or prototyping tools. Use techniques such as display-action-response models to describe screen element names, their properties, and their behavior in detail (Beatty and Chen 2012).

A
Every software development organization should adopt one or more standard
its projects. Various SRS templates are available (for example: ISO/IEC/IEEE 2011; Robertson and Robertson 2013). If your organization tackles various kinds or sizes of projects, such as new, large system development as well as minor enhancements to existing systems, adopt an SRS template for each major project class. See the "Template tactics" sidebar in Chapter 5, "Establishing the business requirements," for some thoughts about how to use document templates effectively.
 
Figure 10-2 illustrates
contains a sample SRS that follows this template. Thi

 
 
y types of projects. Appendix C

nion content website. Some people format
 
such guidance text as "hidden text" in Microsoft Word. That way, you can leave the prompts in the document. If you want a memory jogger, just turn on nonprinting characters to see the information.
 
 

FIGURE 10-2 Proposed template for a software requirements specification.

Sometimes a piece of information could logically be recorded in several template sections. Pick one section and use it consistently for that kind of information on your project. Avoid duplicating information in multiple sections even if it could logically fit in more than one (Wiegers 2006).
Cross-references and hyperlinks can help readers find the information they need.
When you create requirements documents,

 
. The rest of this section describes the information to include in each section of
the SRS.
 
   

1.	Introduction
The introduction presents an overview to help the reader understand how the SRS is organized and how to use it.

1.1	Purpose
Identify the product or application whose requirements are specified in this document, including the revision or release number. If this SRS pertains to only part of a complex system, identify that portion or subsystem. Describe the different types of reader that the document is intended for, such as developers, project managers, marketing staff, users, testers, and documentation writers.

1.2	Document conventions
Describe any standards or typographical conventions used, including the meaning of specific text styles, highlighting, or notations. If you are manually labeling requirements, you might specify the format here for anyone who needs to add one later.

1.3	Project scope
Provide a short description of the software being specified and its purpose. Relate the software to user or corporate goals and to business objectives and strategies. If a separate vision and scope or similar document is available, refer to it rather than duplicating its contents here. An SRS that specifies an incremental release of an evolving product should contain its own scope statement as a subset of the long-term strategic product vision. You might provide a high-level summary of the major features the release contains or the significant functions that it performs.

1.4	References
List any documents or other resources to which this SRS refers. Include hyperlinks to them if they are in a persistent location. These might include user interface style guides, contracts, standards, system requirements specifications, interface specifications, or the SRS for a related product. Provide enough information so that the reader can access each reference, including its title, author, version number, date, source, storage location, or URL.
 
2.	Overall description
This section presents a high-level overview of the product and the environment in which it will be used, the anticipated users, and known constraints, assumptions, and dependencies.

2.1	Product perspective
Describe the product's context and origin. Is it the next member of a growing product line, the next version of a mature system, a replacement for an existing application, or an entirely new product? If this SRS defines a component of a larger system, state how this software relates to the overall system and identify major interfaces between the two. Consider including visual models such as a context diagram or ecosystem map (described in Chapter 5) to show the product's relationship to other systems.

2.2	User classes and characteristics
Identify the various user classes that you anticipate will use this product, and describe their pertinent characteristics. (See Chapter 6, "Finding the voice of the user.") Some requirements might pertain only to certain user classes. Identify the favored user classes. User classes represent a subset of the stakeholders described in the vision and scope document. User class descriptions are a reusable resource. If a master user class catalog is available, you can incorporate user class descriptions by simply pointing to them in the catalog instead of duplicating information here.

2.3	Operating environment
Describe the environment in which the software will operate, including the hardware platform; operating systems and versions; geographical locations of users, servers, and databases; and organizations that host the related databases, servers, and websites. List any other software components or applications with which the system must peacefully coexist. If extensive technical infrastructure work needs to be performed in conjunction with developing the new system, consider creating a separate infrastructure requirements specification to detail that work.

2.4	Design and implementation constraints
There are times when a certain programming language must be used, a particular code library that has already had time invested to develop it needs to be used, and so forth. Describe any factors that will restrict the options available to the developers and the rationale for each constraint.
Requirements that incorporate or are written in the form of solution ideas rather than needs are imposing design constraints, often unnecessarily, so watch out for those. Constraints are described further in Chapter 14, "Beyond functionality."
 
2.5	Assumptions and dependencies
An assumption is a statement that is believed to be true in the absence of proof or definitive knowledge. Problems can arise if assumptions are incorrect, are obsolete, are not shared, or change, so certain assumptions will translate into project risks. One SRS reader might assume that the product will conform to a particular user interface convention, whereas another might assume something different. A developer might assume that a certain set of functions will be custom-written for this application, whereas the business analyst might assume that they will be reused from a previous project, and the project manager might expect to procure a commercial function library. The assumptions to include here are those related to system functionality; business-related assumptions appear in the vision and scope document, as described in Chapter 5.
system being built has on external factors or components outside its control. For instance, if Microsoft .NET Framework 4.5 or a more recent version must be installed before your product can run, that's a dependency.

3.	System features
The template in Figure 10-2 shows functional requirements organized by system feature, which is just one possible way to arrange them. Other organizational options include arranging functional requirements by functional area, process flow, use case, mode of operation, user class, stimulus, and response. Hierarchical combinations of these elements are also possible, such as use cases within user classes. There is no single right choice; select a method of organization that makes it easy for readers to understand the product's intended capabilities. We'll describe the feature scheme as an example.

3.x	System feature X
State the name of the feature in just a few words, such as "3.1 Spell Check." Repeat section 3.x with its subsections 3.x.1 and 3.x.2 for each system feature.

3.x.1	Description
Provide a short description of the feature and indicate whether it is of high, medium, or low priority. (See Chapter 16, "First things first: Setting requirement priorities.") Priorities often are dynamic, changing over the course of the project. If you're using a requirements management tool, define
a requirement attribute for priority. Requirement attributes are discussed in Chapter 27 and requirements management tools in Chapter 30.

3.x.2	Functional requirements
Itemize the specific functional requirements associated with this feature. These are the software capabilities that must be implemented for the user to carry out the feature's services or to perform a use case. Describe how the product should respond to anticipated error conditions and to invalid inputs and actions. Uniquely label each functional requirement, as described earlier in this chapter. If
you're using a requirements management tool, you can create multiple attributes for each functional
requirement, such as rationale, origin, and status.
 
4.	Data requirements
Information systems provide value by manipulating data. Use this section of the template to describe
various aspects of the data that the system will consume as inputs, process in some fashion, or create as outputs. Chapter 13, "Specifying data requirements," addresses this topic in more detail. Stephen Withall (2007) describes many patterns for documenting data (also known as information) requirements precisely.

4.1	Logical data model
As described in Chapter 13, a data model is a visual representation of the data objects and collections the system will process and the relationships between them. Numerous notations exist for data modeling, including entity-relationship diagrams and UML class diagrams. You might include a data model for the business operations being addressed by the system, or a logical representation for the data that the system will manipulate. This is not the same thing as an implementation data model that will be realized in the form of database design.

4.2	Data dictionary
The data dictionary defines the composition of data structures and the meaning, data type, length, format, and allowed values for the data elements that make up those structures. Commercial data modeling tools often include a data dictionary component. In many cases, you're better off storing the data dictionary as a separate artifact, rather than embedding it in the middle of an SRS. That also increases its reusability potential in other projects. Chapter 13 discusses the data dictionary.

4.3	Reports
If your application will generate any reports, identify them here and describe their characteristics. If a report must conform to a specific predefined layout, you can specify that here as a constraint, perhaps with an example. Otherwise, focus on the logical descriptions of the report content, sort sequence, totaling levels, and so forth, deferring the detailed report layout to the design stage. Chapter 13 offers guidance on specifying reports.

4.4	Data acquisition, integrity, retention, and disposal
If relevant, describe how data is acquired and maintained. For instance, when starting a data inventory feed, you might need to do an initial dump of all the inventory data to the receiving system and then have subsequent feeds that consist only of changes. State any requirements regarding the need to protect the integrity of the system's data. Identify any specific techniques that are necessary, such as backups, checkpointing, mirroring, or data accuracy verification. State policies the system must enforce for either retaining or disposing of data, including temporary data, metadata, residual data (such as deleted records), cached data, local copies, archives, and interim backups.
 
5.	External interface requirements
This section provides information to ensure that the system will communicate properly with users and with external hardware or software elements. Reaching agreement on external and internal system interfaces has been identified as a software industry best practice (Brown 1996). A complex system with multiple subcomponents should create a separate interface specification or system architecture specification. The interface documentation could incorporate material from other documents by reference. For instance, it could point to a hardware device manual that lists the error codes that the device could send to the software.


5.1	User interfaces
Describe the logical characteristics of each user interface that the system needs. Some specific characteristics of user interfaces could appear in section 6.1 Usability. Some possible items to address here are:
¦	References to user interface standards or product line style guides that are to be followed
¦	Standards for fonts, icons, button labels, images, color schemes, field tabbing sequences,
commonly used controls, branding graphics, copyright and privacy notices, and the like
¦	Screen size, layout, or resolution constraints
¦	Standard buttons, functions, or navigation links that will appear on every screen, such as a help button
¦	Shortcut keys
¦	Message display and phrasing conventions
¦	Data validation guidelines (such as input value restrictions and when to validate field contents)
 
¦	Layout standards to facilitate software localization
¦	Accommodations for users who are visually impaired, color blind, or have other limitations

5.2	Software interfaces


. State the purpose, formats, and contents of the messages, data, and control values exchanged between the software components. Specify the mappings of input and output data between the systems and any translations that need to be made for the data to get from one system to the other. Describe the services needed by or from external software components and the nature of the inter-component communications. Identify data that will be exchanged between or shared across software components. Specify nonfunctional requirements affecting the interface, such as service levels for response times and frequencies, or security controls and restrictions. Some of this information might be specified as data requirements in section 4 or as interoperability requirements in section 6, Quality attributes.

5.3	Hardware interfaces

. This description might include the supported device types, the data and control interactions between the software and the hardware, and the communication protocols to be used. List the inputs and outputs, their formats, their valid values or ranges, and any timing issues developers need to be aware of. If this information is extensive, consider creating a separate interface specification document. For more about specifying requirements for systems containing hardware, see Chapter 26, "Embedded and other real-time systems projects."

5.4	Communications interfaces
State the requirements for any communication functions the product will use, including email, web browser, network protocols, and electronic forms. Define any pertinent message formatting. Specify communication security and encryption issues, data transfer rates, handshaking, and synchronization mechanisms. State any constraints around these interfaces, such as whether certain types of email attachments are acceptable or not.

6.	Quality attributes
This section specifies nonfunctional requirements other than constraints, which are recorded in
section 2.4, and external interface requirements, which appear in section 5. These quality requirements should be specific, quantitative, and verifiable. Indicate the relative priorities of various attributes,
such as ease of use over ease of learning, or security over performance. A rich specification notation such as Planguage clarifies the needed levels of each quality much better than can simple descriptive statements (see the "Specifying quality requirements with Planguage" section in Chapter 14).
Chapter 14 presents more information about these quality attribute requirements and many examples.
 
6.1	Usability
Usability requirements deal with ease of learning, ease of use, error avoidance and recovery, efficiency of interactions, and accessibility. The usability requirements specified here will help the user interface designer create the optimum user experience.

6.2	Performance
State specific performance requirements for various system operations. If different functional requirements or features have different performance requirements, it's appropriate to specify those performance goals right with the corresponding functional requirements, rather than collecting them in this section.

6.3	Security
Specify any requirements regarding security or privacy issues that restrict access to or use of the product. These could refer to physical, data, or software security. Security requirements often originate in business rules, so identify any security or privacy policies or regulations to which the product must conform. If these are documented in a business rules repository, just refer to them.

6.4	Safety
Specify requirements that are concerned with possible loss, damage, or harm that could result
from use of the product. Define any safeguards or actions that must be taken, as well as potentially dangerous actions that must be prevented. Identify any safety certifications, policies, or regulations to which the product must conform.

6.	x [Others]
Create a separate section in the SRS for each additional product quality attribute to describe characteristics that will be important either to customers or to developers and maintainers. Possibilities include availability, efficiency, installability, integrity, interoperability, modifiability, portability, reliability, reusability, robustness, scalability, and verifiability. Chapter 14 describes a procedure for focusing on those attributes that are of most importance to a particular project.

7.	Internationalization and localization requirements
Internationalization and localization requirements ensure that the product will be suitable for use in nations, cultures, and geographic locations other than those in which it was created. Such
requirements might address differences in currency; formatting of dates, numbers, addresses, and telephone numbers; language, including national spelling conventions within the same language (such as American versus British English), symbols used, and character sets; given name and
family name order; time zones; international regulations and laws; cultural and political issues; paper sizes used; weights and measures; electrical voltages and plug shapes; and many others. Internationalization and localization requirements could well be reusable across projects.
 
8.	[Other requirements]
Define any other requirements that are not covered elsewhere in the SRS. Examples are legal, regulatory, or financial compliance and standards requirements; requirements for product installation, configuration, startup, and shutdown; and logging, monitoring, and audit trail requirements. Instead of just combining these all under "Other," add any new sections to the template that are pertinent
to your project. Omit this section if all your requirements are accommodated in other sections. Transition requirements that are necessary for migrating from a previous system to a new one could be included here if they involve software being written (as for data conversion programs), or in the project management plan if they do not (as for training development or delivery).

Appendix A: Glossary
Define any specialized terms that a reader needs to know to understand the SRS, including acronyms and abbreviations. Spell out each acronym and provide its definition. Consider building a reusable enterprise-level glossary that spans multiple projects and incorporating by reference any terms that pertain to this project. Each SRS would then define only those terms specific to an individual project that do not appear in the enterprise-level glossary. Note that data definitions belong in the data dictionary, not the glossary.

Appendix B: Analysis models
This optional section includes or points to pertinent analysis models such as data flow diagrams, feature trees, state-transition diagrams, or entity-relationship diagrams. (See Chapter 12, "A picture is worth 1024 words.") Often it's more helpful for the reader if you incorporate certain models into the relevant sections of the specification instead of collecting them at the end.

Requirements




ecific stories to iterations. The team might aggregate a group of related stories into a "minimally marketable feature" that needs to be fully implemented prior to a product release so the feature delivers the expected customer value.

. Large stories that encompass significant functionality that cannot be implemented within
a single iteration are subdivided into smaller stories, which are allocated to multiple iterations for
implementation. (See Chapter 20, "Agile projects.") User stories can be recorded on something as simple
 
as index cards, instead of in a traditional document. Some agile teams record their stories in a story management tool, whereas others don't retain them at all following implementation.


 
. That is, specification involves the progressive refinement of detail at the right stage of the project, which is a good practice on any project. Those details generally correspond to what we have identified as functional requirements in the SRS. However, agile projects often represent those details in the form of user acceptance tests that describe how the system will behave if the story is properly implemented. The tests for a story are conducted during the iteration in which the story is implemented and in future iterations for regression testing. As with all tests, they should cover exception conditions as well as the expected behavior. These acceptance tests can be written on cards as well or recorded in a more persistent form, such as in a testing tool. Tests should be automated to assure rapid and complete regression testing. If the team elects to discard the original
user stories, then the only persistent documentation of the requirements is likely to be the acceptance
tests, if they are stored in a tool.

(Cohn 2004). Alternatively, teams might specify nonfunctional requirements that are associated with a specific user story in the form of acceptance criteria or tests, such as to demonstrate achievement of specific quality attribute goals. As an example, security tests might demonstrate that certain users are permitted to access the functionality described in a particular user story but that the system blocks access for other users. The agile team is not precluded from using other methods to represent requirements knowledge, such as analysis models or a data dictionary. They should select whatever representation techniques are customary and appropriate for their culture and project.
It's up to each project team to choose the most appropriate forms for specifying its software requirements. Remember the overarching goal of requirements development: to accumulate a shared understanding of requirements that is good enough to allow construction of the next portion of the product to proceed at an acceptable level of risk. The appropriate level of formality and detail in which to document requirements depends on factors including the following:
¦	The extent to which just-in-time informal verbal and visual communication between customers and developers can supply the necessary details to permit the correct implementation of each user requirement
¦	The extent to which informal communication methods can keep the team effectively synchronized across time and space
¦	The extent to which it is valuable or necessary to retain requirements knowledge for future enhancement, maintenance, application reengineering, verification, statutory and audit mandates, product certification, or contractual satisfaction
¦	The extent to which acceptance tests can serve as effective replacements for descriptions of
the expected system capabilities and behaviors
¦	The extent to which human memories can replace written representations
 
No matter what type of product the team is building, what development life cycle they are following, or what elicitation techniques the BA is using, effective requirements specification is an essential key to success. There are many ways to achieve this. Just remember that when you don't specify high-quality requirements, the resulting software is like a box of chocolates: you never know what you're going to get.


 

 
C HA P T E R 1 1
Writing excellent requirements

"Hi, Gautam. This is Ruth calling from the Austin branch. We got that latest drop of the website software for the online music store. I wanted to ask you about the song preview feature. That's not working the way I had in mind."
Gautam replied, "Let me find the requirements you sent for that. Here they are. The user story said, 'As a Customer, I want to listen to previews of the available songs so I can decide which ones to buy.' My notes say that when we discussed this, you said each song sample should be 30 seconds long and that it should use our built-in MP3 player so the customer didn't have to wait for another player to launch. Isn't that working correctly?"
"Well, yes, that all works fine," said Ruth, "but there are a couple of problems. I can click on the
play icon to start the sample, but I don't have any way to pause it or stop it. I'm forced to listen to the entire 30-second sample. Also, all the samples start at the beginning of the song. Some songs have long introductions so you really can't hear what they're like from just the beginning. The sample should start somewhere in the middle of those songs so people could hear what they're really like. And the sample starts playing at full volume and then stops abruptly. If the customer's speakers are up pretty loud this could be startling. I think it would be better if we fade in and fade out on each sample."
Gautam was a little frustrated. "I wish you had told me all of this when we spoke earlier. You didn't give me much to go on so I just had to make my best guess. I can do all that, but it's going to take a few more days."
Th
. This chapter describes desirable ch
ements, along with many examples
of flawed requirements and suggestions for improving them. These recommendations apply to the requirements that are created for any project following any development life cycle. The requirements authors on each project need to judge the appropriate level of precision and detail for their requirements, but there's no substitute for clear communication.

Characteristics of excellent requirements
How can you tell good requirements from those with problems? This section describes several characteristics that individual requirement statements should exhibit, followed by desirable characteristics of the requirements set as a whole (Davis 2005; ISO/IEC/IEEE 2011). The best way
203
 
to tell whether your requirements possess these desired attributes is to have several stakeholders review them. Different stakeholders will spot different kinds of problems. Chapter 17, "Validating the requirements," describes the use of checklists to remind reviewers of common requirements errors.

In an ideal world, every individual business, user, functional, and nonfunctional requirement would
exhibit the qualities described in the following sections.

Each requirement must contain al	nd it. In the
 
case of

as a standard
on later. Resolve all
 
s, this means
you know you
 

formation, use TBD (to be determined)
 

 

 
Correct
Each r

to check its correctness. Th system requirement, a use cas
 



t. You'll have to go to the source of the requirement
l
ument. A low-level requirement
 
that conflicts with its parent is not correct. To assess the correctness of user requirements, user representatives or their close surrogates should review them.

Feasible
It must be
f. A developer who participates during elicitation can provide a reality check on what can and cannot be done technically and what can be done only at excessive cost or effort. Incremental development approaches and proof-of-concept prototypes are two ways to evaluate requirement
feasibility. If a requirement needs to be cut because it is not be feasible, understand the impact on the project vision and scope.

Necessary
Each requirement should describe a
,
. Every requirement should originate from a source that has the authority to provide requirements. Trace functional and nonfunctional requirements back to specific voice-of-the-user input, such as a use case or user story. You should be able to relate eachrequirement to a business objective that clearly indicates why it's necessary. If someone asks why a particular requirement is included, there should be a good answer.



 
e. If all requirements are equally important, the project manager doesn't know how best to respond to schedule overruns, personnel losses, or new requirements that come along. Requirements prioritization should be a collaborative activity involving multiple stakeholder perspectives. Chapter 16, "First things first: Setting requirement priorities," discusses prioritization in further detail.

Unambiguous
. One type I can spot myself, when I can think of he other type of ambiguity is harder to catch.
That's when different people read the requirement and come up with different interpretations of it. The requirement makes sense to each of them but means something different to each of them.
Inspections are a good way to spot ambiguities (Wiegers 2002). A formal peer review such as an inspection (as opposed to just passing out the requirements to individuals to examine on their own) provides an opportunity for each participant to compare his understanding of each requirement to someone else's. "Comprehensible" is related to "unambiguous": readers must understand what each requirement is saying. Chapter 17 describes the software peer review process.
You'll never remove all the ambiguity from requirements-that's th	.
Most of the time, reasonable people can draw the right conclusions from even a slightly requirement. Getting a little help from your colleagues through reviews will clean up a lot of the worst issues, though.

Verifiable
Can a i

   
. Include them in your requirements peer reviews to catch problems early.


It's not enough to have excellent individual requirement statements.
exhibit the characteristics described in the following sections, whether they are recorded in an SRS document, a requirements management tool, a set of user stories and acceptance tests, or any other form.
 
Complete
N
 

nt. In practice,
. There are always some assumed or implied requirements, although
 
they carry more risk than explicitly stated requirements. Missing requirements are hard to spot because they aren't there! The section "Avoiding incompleteness" later in this chapter suggests some ways to identify missing requirements. Any specification that contains TBDs is incomplete.

Consistent
other r	l
m. Recording the
of each requirement lets you know who to talk to if you discover conflicts. It can be hard to spot inconsistencies when related information is stored in different locations, such as in a vision and scope document and in a requirements management tool.

Modifiable

d. You also need to know about connections and dependencies between requirements so you can find all the ones that must be changed together. Modifiability dictates that each requirement be uniquely labeled and expressed separately from others so you can refer to it unambiguously. See Chapter 10, "Documenting the requirements," for various ways to label requirements.
To
er to read but harder to maintain (Wiegers 2006). The multiple instances of the requirement all have to be modified at the same time to avoid generating inconsistencies. Cross-reference related items in the SRS to help keep them synchronized when making changes. Storing individual requirements just once in a requirements management tool solves the redundancy problem and facilitates reuse of common requirements across multiple projects. Chapter 18, "Requirements reuse," offers several strategies for reusing requirements.



 
Note that you don't actually have to define all of these trace links for a requirement to have the properties that make it traceable.
. They are written in a structured, fine-grained way, not in long narrative paragraphs. Avoid combining multiple requirements together into a single statement, because the different requirements might trace to different development components. Chapter 29, "Links in the requirements chain," addresses requirements tracing.
 
You're never going to create a perfect specification in which all requirements demonstrate all of these ideal attributes. But if you keep these characteristics in mind when you write and review the requirements, you'll produce better requirements specifications and better software.



 

 
There is no
 
s;
. Receiving c
 

back from colleagues
 
with sharp eyes is a great help because you can learn where your writing did and didn't hit the mark.
 
This is
buddy up with a fellow business analyst and begin
 
. To get started with reviews,
. You'll learn
 

   

 
e numerous tips for writing requirements-particularly f	hat readers
can clearly understand. Benjamin Kovitz (1999), Ian Alexander and Richard Stevens (2002), and Karl Wiegers (2006) present many other recommendations and examples for writing good requirements.
When we say "writing requirements," people immediately think of writing textual requirements in natural language. It's better to mentally translate the phrase "writing requirements" to "representing requirements knowledge." In many cases, alternative representation techniques can present information more effectively than can straight text (Wiegers 2006). The BA should choose an appropriate mix of communication methods that ensures a clear, shared understanding of both the stakeholder needs and the solution to be built.
The sample requirements presented here can always be improved upon, and there are always equivalent ways to state them. Two important goals of writing requirements are that:
¦	Anyone who reads the requirement comes to the same interpretation as any other reader.
¦	Each reader's interpretation matches what the author intended to communicate.
These outcomes are more important than purity of style or conforming dogmatically to some arbitrary rule or convention.

You can write functional requirements from the perspective of either something the system does or something the user can do. Because effective communication is the overarching goal, it's fine to
intermingle these styles, phrasing each requirement in whichever style is clearer. State requirements in a consistent fashion, such as "The system shall" or "The user shall," followed by an action verb, followed by the observable result. Specify the trigger action or condition that causes the system
to perform the specified behavior. A generic template for a requirement written from the system's perspective is (Mavin et al. 2009):
[optional precondition] [optional trigger event] the system shall [expected system response].
 
This template is from the Easy Approach to Requirements Syntax (EARS). EARS also includes additional template constructs for event-driven, unwanted behavior, state-driven, optional, and complex requirements. Following is an example of a simple functional requirement that describes a system action using this template:
If the requested chemical is found in the chemical stockroom, the system shall display a list of all containers of the chemical that are currently in the stockroom.
This example includes a precondition, but not a trigger. Some requirement writers would omit the phrase "the system shall" from this requirement. They argue that, because the requirements are describing system behavior, there's no need to repetitively say "the system shall" do this or that. In this example, deleting "the system shall" is not confusing. Sometimes, though, it's more natural to phrase the requirement in terms of a user's action, not from the system's perspective. Including the "shall" and writing in the active voice makes it clear what entity is taking the action described.
When writing functional requirements from the user's perspective, the following general structure
works well (Alexander and Stevens 2002):


 
Alternative phrasings are "The system shall let (or allow, permit, or enable) the [a particular user class name] to [do something]." Following is an example of a functional requirement written from the user's perspective:


 
Notice how this requirement uses the name of the user class-Chemist-in place of the generic "user." Making the requirement as explicit as possible reduces the possibility of misinterpretation.

W

   
Adjust your writing style to put the punch line-the statement of need or functionality-first, followed by supporting details (rationale, origin, priority, and other
requirement attributes).	,
isual elements helps to break up a monotonous litany of
ion to those who learn best in different ways.
Nor are requirements documents the place to practice your creative writing skills. Avoid interleaving passive and active voice in an attempt to make the material more interesting to read. Don't use multiple terms for the same concept just to achieve variety (customer, account, patron,
. Being easy to read and understand is an essential element of well-written requirements; being interesting is, frankly, less important. If you are not a skilled writer, you should expect that yourreaders might not understand what you intend to convey. Keep the tips that follow in mind as you craft your requirements statements for maximum communication effectiveness.
ness  Write requirements in complete sentences using	,
. Keep sentences and paragraphs short and direct. Write requirements in simple and straightforward language appropriate to the user domain, avoiding jargon.
.
Another good guideline is to write concisely. Phrases like "needs to provide the user with the capability to" can be condensed to "shall." For each piece of information in the requirements set, ask yourself, "What would the reader do with this information?" If you aren't certain that some stakeholder would find that information valuable, perhaps you don't need it.
Precisely stated requirements increase the chance of people receiving what they expect; less specific requirements offer the developer more latitude for interpretation. Sometimes that lack of specificity is fine, but in other cases it can lead to too much variability in the outcome.


The keyword "shall" A traditional convention is to use the keyword "shall" to describe some system capability. People sometimes object to the word "shall." "That's not how people talk," they protest. So what? "
to," or something similar, but be consistent. I sometimes read specifications that contain a random and confusing mix of requirements verbs: shall, must, may, might, will, would, should, could, needs to, has to, should provide, and others. I never know if there are differences between the meanings of these or not. Nuances between different verbs also make the document far more difficult for cross-cultural teams to interpret consistently. You're better off sticking with a keyword such as "shall."
Some requirement authors deliberately use different verbs to imply subtle distinctions. They use certain keywords to connote priority:
.
. Also, priorities will change as iterations proceed, so don't tie them to the phrasing of the requirements. Today's "must" could become tomorrow's "should." Other authors use "shall" to indicate a requirement and "will" to denote a design expectation. Such conventions run the risk of some
.

 
Write in the active voice to make it clear what entity is taking the action described. Much business and scientific writing is in the passive voice, but it is never as clear and direct as using the active voice. The following requirement is written in passive voice:
Upon product upgrade shipment, the serial number will be updated on the contract line.
The phrasing "will be updated" is indicative of passive voice. It denotes the recipient of the action (serial number) but not the performer of the action. That is, this phrasing offers no clue as to who or what updates the serial number. Will the system do that automatically, or is the user expected to
update the serial number? Rephrasing this requirement into active voice makes the actor explicit and also clarifies the triggering event:
W
Individual requirements Avoid writing long narrative paragraphs that contain multiple requirements. Readers shouldn't have to glean the individual requirements embedded in a mass of free-flowing descriptive language. Clearly distinguish individual requirements from background or contextual information. Such information is valuable to readers, but they need to unambiguously recognize the actual requirement statements. I once reviewed a large requirements specification written in the form of long paragraphs. I could read a full page and understand it, but I had to work hard to pick out the discrete requirements. Other readers might well come to different conclusions of exactly what requirements were lurking in that mass of text.
Words such as "and," "or," "additionally," or "also" in a requirement suggest that several requirements might have been combined. This doesn't mean you can't use "and" in a requirement; just make sure the conjunction is joining two parts of a single requirement instead of two separate

 
; it leaves the interpretation up to the reader, as in this case:
The system must permit search by order number, invoice number, and/or customer purchase order number.
This requirement would permit the user to enter one, two, or three numbers at once when performing a single search. That might not be what's intended.
The words "unless," "except," and "but" also indicate the presence of multiple requirements:
The Buyer's credit card on file shall be charged for payment, unless the credit card has expired.
Failing to specify

 
 


and
 
If the Buyer's credit card on file is active, the system shall charge the payment to that card.


If the Buyer's credit card on file has expired, the system shall allow the Buyer to either update
the current credit card information or enter a new credit card for payment.
 

 
Level of detail
Requirements n
just enough information	m.
Appropriate detail    An im
 


rs with

l
 
larify it and flesh it out. There's no single correct answer to the commonly asked question, "How detailed should the requirements be?"
, based on the de	nce.
The fewer the opportunities for ongoing discussion about requirements issues, the more specifics you need to record in the requirements set. If a developer can think of several possible ways to satisfy a requirement and all are acceptable, the specificity and detail are about right.
detail when (Wiegers 2006):
¦	The work is being done for an external client.
¦	Development or testing will be outsourced.
¦	Project team members are geographically dispersed.
¦	System testing will be based on requirements.
¦	Accurate estimates are needed.
¦	Requirements traceability is needed.
It's safe to include less detail when:
¦	The work is being done internally for your company.
¦	Customers are extensively involved.
¦	Developers have considerable domain experience.
¦	Precedents are available, as when a previous application is being replaced.
¦	A package solution will be used.
 
Consistent
 
uirement authors often struggle to find the right level of granularity nts. It's not necessary to specify all of your requirements to the
 
same level of detail. For example, you might go into more depth in an area that presents higher risk than others. Within a set of related requirements, though, it's a good idea to try to write functional requirements at a consistent level of granularity.
