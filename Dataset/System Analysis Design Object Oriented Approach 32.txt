The most important step of the design phase is designing the individual classes and methods. Object-oriented systems can be quite complex, so analysts need to create instructions 
and guidelines for programmers that clearly describe what the system must do. Th is chapter 
presents a set of criteria, activities, and techniques used to design classes and methods. Together 
they are used to ensure that the object-oriented design communicates how the system needs 
to be coded.
OBJECTIVES
■ Become familiar with coupling, cohesion, and connascence.
■ Be able to specify, restructure, and optimize object designs.
■ Be able to identify the reuse of predefi ned classes, libraries, frameworks, and components.
■ Be able to specify constraints and contracts.
■ Be able to create a method specifi cation.
INTRODUCTION
WARNING: Th is material may be hazardous to your mental stability. Not really, but now that 
we have your attention, you must realize that this material is fairly technical in nature and 
that it is extremely important in today’s “fl at” world. Today, much of the actual implementation will be done in a diff erent geographic location than where the analysis and design are 
performed. We must ensure that the design is specifi ed in a “correct” manner and that there 
is no, or at least minimal, ambiguity in the design specifi cation.
In today’s fl at world, the common language spoken among developers is very likely to be 
UML and some object-oriented language, such as Java, and not English. English has always 
been and always will be ambiguous. Furthermore, to what variety of English do we refer? As 
both Oscar Wilde and George Bernard Shaw independently pointed out, the United States 
and England are divided by a common language. 
Practically speaking, Class and Method design is where all the work actually gets done 
during design. No matter which layer you are focusing on, the classes, which will be used 
to create the system objects, must be designed. Some people believe that with reusable class 
libraries and off -the-shelf components, this type of low-level, or detailed, design is a waste 
of time and that we should jump immediately into the “real” work: coding the system. 
However, past experience shows that low-level, or detailed, design is critical despite the 
use of libraries and components. Detailed design is still very important for three reasons. 
First, with today’s modern CASE tools, quite a bit of the actual code can be generated by the 
tool from the detailed design. Second, even preexisting classes and components need to be 
understood, organized, and pieced together. Th ird, it is still common for the project team 
CHAPTER 8
Class and Method Design
280
Introduction  281
to have to write some code and produce original classes that support the application logic 
of the system.
Jumping right into coding will guarantee disastrous results. For example, even though 
the use of layers can simplify the individual classes, they can increase the complexity of the 
interactions between them. If the classes are not designed carefully, the resulting system can 
be very ineffi cient. Or worse, the instances of the classes (i.e., the objects) will not be capable 
of communicating with each other, which will result in the system’s not working properly.
In an object-oriented system, changes can take place at diff erent levels of abstraction. 
Th ese levels include variable, method, class/object, package,1 library, and/or application/ 
system levels (see Figure 8-1). Th e changes that take place at one level can aff ect other levels 
(e.g., changes to a class can aff ect the package level, which can aff ect both the system level 
and the library level, which in turn can cause changes back down at the class level). Finally, 
changes can occur at diff erent levels at the same time.
Th e good news is that the detailed design of the individual classes and methods is 
fairly straightforward. Th e interactions among the objects on the problem-domain layer 
have been designed, in some detail, during analysis (see Chapters 4 through 6). Th e other 
layers (data management, human–computer interaction, and physical architecture) are 
highly dependent on the problem-domain layer. Th erefore, if the problem-domain classes 
are designed correctly, the design of the classes on the other layers will fall into place, 
relatively speaking.
Th at being said, it has been our experience that many project teams are much too quick 
at jumping into writing code for the classes without fi rst designing them. Some of this has 
been caused by the fact that object-oriented systems analysis and design has evolved from 
object-oriented programming. Until recently there has been a general lack of accepted guidelines on how to design and develop eff ective object-oriented systems. However, with the 
Class/Object
Package
System
Library
Variable Method FIGURE 8-1
Levels of Abstraction 
in Object-Oriented 
Systems
Source: Based on material from David P. Tegarden, Steven D. Sheetz, and David E. Monarchi, “A Software 
Complexity Model of Object-Oriented Systems,” Decision Support Systems 13 (March 1995): 241–262.
1 A package is a group of collaborating objects. Other names for a package include cluster, partition, pattern, subject, 
and subsystem.
282 Chapter 8 Class and Method Design
acceptance of UML as a standard object notation, standardized approaches based on work of 
many object methodologists have begun to emerge.2
REVIEW OF THE BASIC CHARACTERISTICS 
OF OBJECT ORIENTATION
Object-oriented systems can be traced back to the Simula and the Smalltalk programming languages. However, until the increase in processor power and the decrease in processor cost that 
occurred in the 1980s, object-oriented approaches were not practical. Many of the specifi c details 
concerning the basic characteristics of object-orientation are language dependent; that is, each 
object-oriented programming language tends to implement some of the object-oriented basics 
in a diff erent way. Consequently, we need to know which programming language is going to be 
used to implement the diff erent aspects of the solution. Otherwise, the system could behave in a 
manner diff erent than the analyst, designer, and client expect. Today, the C11, Java, Objective-C, 
and Visual Basic programming languages tend to be the more predominant languages used. In 
this section, we review the basic characteristics of object orientation and point out where the 
 language-specifi c issues emerge.
Classes, Objects, Methods, and Messages
Th e basic building block of the system is the object. Objects are instances of classes. Classes are 
templates that we use to defi ne both the data and processes that each object contains. Each 
object has attributes that describe data about the object. Objects have state, which is defi ned 
by the value of its attributes and its relationships with other objects at a particular point in 
time. And each object has methods, which specify what processes the object can perform. 
From our perspective, methods are used to implement the operations that specifi ed the behavior of the objects (see Chapter 5). To get an object to perform a method (e.g., to delete itself), 
a message is sent to the object. A message is essentially a function or procedure call from one 
object to another object.
Encapsulation and Information Hiding
Encapsulation is the mechanism that combines the processes and data into a single object. 
Information hiding suggests that only the information required to use an object be available 
outside the object; that is, information hiding is related to the visibility of the methods and 
attributes (see Chapter 5). Exactly how the object stores data or performs methods is not 
relevant, as long as the object functions correctly. All that is required to use an object are the 
set of methods and the messages needed to be sent to trigger them. Th e only communication 
between objects should be through an object’s methods. Th e fact that we can use an object by 
sending a message that calls methods is the key to reusability because it shields the internal 
workings of the object from changes in the outside system, and it keeps the system from being 
aff ected when changes are made to an object.
Polymorphism and Dynamic Binding
Polymorphism means having the ability to take several forms. By supporting polymorphism, object-oriented systems can send the same message to a set of objects, which can be 
2 For example, OPEN [I. Graham, B. Henderson-Seller, and H. Yanoussi, Th e Open Process Specifi cation (Reading, 
MA: Addison-Wesley, 1997)], RUP [P. Kruchten, Th e Rational Unifi ed Process: An Introduction, 2nd ed. (Reading, 
MA: Addison-Wesley, 2000)], and the Enhanced Unifi ed Process (see Chapter 1).
Review of the Basic Characteristics of Object Orientation  283
 interpreted diff erently by diff erent classes of objects. Based on encapsulation and information 
hiding, an object does not have to be concerned with how something is done when using other 
objects. It simply sends a message to an object and that object determines how to interpret the 
message. Th is is accomplished through the use of dynamic binding.
Dynamic binding refers to the ability of object-oriented systems to defer the data typing 
of objects to run time. For example, imagine that you have an array of type employee that 
contains instances of hourly employees and salaried employees (see Figure 8-2). Both these 
types of employees implement a compute pay method. An object can send the message to 
each instance contained in the array to compute the pay for that individual instance. Depending on whether the instance is an hourly employee or a salaried employee, a diff erent method 
will be executed. Th e specifi c method is chosen at run time. With this ability, individual 
classes are easier to understand. However, the specifi c level of support for polymorphism and 
dynamic binding is language specifi c. Most object-oriented programming languages support 
dynamic binding of methods, and some support dynamic binding of attributes.
But polymorphism can be a double-edged sword. Th rough the use of dynamic binding, 
there is no way to know before run time which specifi c object will be asked to execute its 
method. In eff ect, there is a decision made by the system that is not coded anywhere.3 Because 
all these decisions are made at run time, it is possible to send a message to an object that it 
does not understand (i.e., the object does not have a corresponding method). Th is can cause 
a run-time error that, if the system is not programmed to handle it correctly, can cause the 
system to abort.4
Finally, if the methods are not semantically consistent, the developer cannot assume 
that all methods with the same name will perform the same generic operation. For example, 
imagine that you have an array of type person that contains instances of employees and customers (see Figure 8-3). Th ese both implement a compute pay method. An object can send 
the message to each instance contained in the array to execute the compute pay method for 
that individual instance. In the case of an instance of employee, the compute pay method 
computes the amount that the employee is owed by the fi rm, whereas the compute pay 
method associated with an instance of a customer computes the amount owed the fi rm by 
the customer. Depending on whether the instance is an employee or a customer, a diff erent 
meaning is associated with the method. Th erefore, the semantics of each method must be 
determined individually. Th is substantially increases the diffi culty of understanding individual objects. Th e key to controlling the diffi culty of understanding object- oriented systems 
Array Employee contains
+computePay()
HourlyEmployee
+computePay()
SalariedEmployee
+computePay()
* *
FIGURE 8-2
Example of 
Polymorphism
3 From a practical perspective, there is an implied case statement. Th e system chooses the method based on the type of 
object being asked to execute it and the parameters passed as arguments to the method. Th is is typically done through 
message dispatch tables that are hidden from the programmer.
4 In most object-oriented programming languages, these errors are referred to as exceptions that the system “throws” 
and must “catch.” In other words, the programmer must correctly program the throw and catch or the systems will 
abort. Again, each programming language can handle these situations in a unique manner.
284 Chapter 8 Class and Method Design
when using polymorphism is to ensure that all methods with the same name implement that 
same generic operation (i.e., they are semantically consistent).
Inheritance
Inheritance allows developers to defi ne classes incrementally by reusing classes defi ned previously as the basis for new classes. Although we could defi ne each class separately, it might 
be simpler to defi ne one general superclass that contains the data and methods needed by 
the subclasses and then have these classes inherit the properties of the superclass. Subclasses 
inherit the attributes and methods from the superclasses above them. Inheritance makes it 
simpler to defi ne classes.
Th ere have been many diff erent types of inheritance mechanisms associated with 
object-oriented systems.5 Th e most common inheritance mechanisms include diff erent forms 
of single and multiple inheritance. Single inheritance allows a subclass to have only a single 
parent class. Currently, all object-oriented methodologies, databases, and programming languages permit extending the defi nition of the superclass through single inheritance.
Some object-oriented methodologies, databases, and programming languages allow a subclass to redefi ne some or all the attributes and/or methods of its superclass. With redefi nition
capabilities, it is possible to introduce an inheritance confl ict [i.e., an attribute (or method) of 
a subclass with the same name as an attribute (or method) of a super-class]. For example in 
Figure 8-4, Doctor is a subclass of Employee. Both have methods named ComputePay(). Th is 
causes an inheritance confl ict. Furthermore, when the defi nition of a superclass is modifi ed, all 
its subclasses are aff ected. Th is can introduce additional inheritance confl icts in one (or more) 
of the superclass’s subclasses. For example in Figure 8-4, Employee could be modifi ed to include 
an additional method, UpdateSchedule(). Th is would add another inheritance confl ict between 
Employee and Doctor. Th erefore, developers must be aware of the eff ects of the modifi cation 
not only in the superclass but also in each subclass that inherits the modifi cation.
Finally, through redefi nition capabilities, it is possible for a programmer to arbitrarily 
cancel the inheritance of methods by placing stubs6 in the subclass that will override the 
Array Person
Customer
HourlyEmployee SalariedEmployee
Employee
Contains
+computePay()
+computePay() +computePay()
+computePay() +computePay()
* *
FIGURE 8-3
Example of 
Polymorphism Misuse 
5 See, for example, M. Lenzerini, D. Nardi, and M. Simi, Inheritance Hierarchies in Knowledge Representation and 
Programming Languages (New York: Wiley, 1991).
6 In this case, a stub is simply the minimal defi nition of a method to prevent syntax errors from occurring.
Review of the Basic Characteristics of Object Orientation  285
defi nition of the inherited method. If the cancellation of methods is 
necessary for the correct defi nition of the subclass, then it is likely that 
the subclass has been misclassifi ed (i.e., it is inheriting from the wrong 
superclass).
As you can see, from a design perspective, inheritance confl icts and 
redefi nition can cause all kinds of problems with interpreting the fi nal 
design and implementation.7 However, most inheritance confl icts are 
due to poor classifi cation of the subclass in the inheritance hierarchy (the 
generalization a-kind-of semantics are violated), or the actual inheritance 
mechanism violates the encapsulation and information hiding principle (i.e., subclasses are capable of directly addressing the attributes or 
methods of a superclass). To address these issues, Jim Rumbaugh and his 
colleagues suggested the following guidelines:8
■ Do not redefi ne query operations.
■ Methods that redefi ne inherited ones should restrict only the 
semantics of the inherited ones.
■ Th e underlying semantics of the inherited method should never 
be changed.
■ Th e signature (argument list) of the inherited method should 
never be changed.
However, many existing object-oriented programming languages violate 
these guidelines. When it comes to implementing the design, diff erent object-oriented programming languages address inheritance confl icts diff erently. Th erefore, it is important at 
this point in the development of the system to know what the chosen programming language 
supports. We must be sure that the design can be implemented as intended. Otherwise, the 
design needs to be modifi ed before it is turned over to remotely located programmers.
When considering the interaction of inheritance with polymorphism and dynamic binding, object-oriented systems provide the developer with a very powerful, but dangerous, set 
of tools. Depending on the object-oriented programming language used, this interaction can 
allow the same object to be associated with diff erent classes at diff erent times. For example, an 
instance of Doctor can be treated as an instance of Employee or any of its direct and indirect 
superclasses, such as SalariedEmployee and Person, respectively (see Figure 8-4). Th erefore, 
depending on whether static or dynamic binding is supported, the same object may execute diff erent implementations of the same method at diff erent times. Or, if the method is 
defi ned only with the SalariedEmployee class and it is currently treated as an instance of the 
Employee class, the instance could cause a run-time error to occur.9 It is important to know 
what object-oriented programming language is going to be used so that these kinds of issues 
can be solved with the design, instead of the implementation, of the class.
With multiple inheritance, a subclass may inherit from more than one superclass. In this 
situation, the types of inheritance confl icts are multiplied. In addition to the possibility of 
having an inheritance confl ict between the subclass and one (or more) of its superclasses, it 
is now possible to have confl icts between two (or more) superclasses. In this latter case, three 
diff erent types of additional inheritance confl icts can occur:
Person
Employee
SalariedEmployee
Doctor
+computePay()
+computePay()
+computePay()
+computePay()
+updateSchedule()
FIGURE 8-4
Example of 
 Redefi nition and 
 Inheritance Confl ict 
7 For more information, see Ronald J. Brachman, “I Lied about the Trees Or, Defaults and Defi nitions in Knowledge 
Representation,” AI Magazine 5, no. 3 (Fall 1985): 80–93.
8 J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, Object-Oriented Modeling and Design (Englewood Cliff s, NJ: Prentice Hall, 1991).
9 Th is happens with novices quite regularly when using C11.
286 Chapter 8 Class and Method Design
■ Two inherited attributes (or methods) have the same name (spelling) and semantics.
■ Two inherited attributes (or methods) have diff erent names but identical semantics 
(i.e., they are synonyms).
■ Two inherited attributes (or methods) have the same name but diff erent semantics 
(i.e., they are heteronyms, homographs, or homonyms). Th is also violates the proper 
use of polymorphism.
For example, in Figure 8-5, Robot-Employee is a subclass of both Employee and Robot. 
In this case, Employee and Robot confl ict with the attribute name. Which one should 
Robot-Employee inherit? Because they are the same, semantically speaking, does it really 
matter? It is also possible that Employee and Robot could have a semantic confl ict on the 
 classifi cation and type attributes if they have the same semantics. Practically speaking, 
the only way to prevent this situation is for the developer to catch it during the design of the 
subclass. Finally, what if the runningTime attributes have diff erent semantics? In the case 
of Employee objects, the runningTime attribute stores the employee’s time running a mile, 
whereas the runningTime attribute for Robot objects stores the average time between checkups. Should Robot-Employee inherit both of them? It really depends on whether the robot 
employees can run the mile or not. With the potential for these additional types of confl icts, 
there is a risk of decreasing the understandability in an object-oriented system instead of 
increasing it through the use of multiple inheritance. Our advice is to use great care when 
using multiple inheritance.
DESIGN CRITERIA
When considering the design of an object-oriented system, a set of criteria exists that can be 
used to determine whether the design is a good one or a bad one. According to Coad and 
Yourdon,10 “A good design is one that balances trade-off s to minimize the total cost of the 
system over its entire lifetime.” Th ese criteria include coupling, cohesion, and connascence.
Coupling
Coupling refers to how interdependent or interrelated the modules (classes, objects, and methods) are in a system. Th e higher the interdependency, the more likely changes in part of a design 
Employee Robot
Robot-Employee
-name
-classification
-runningTime
-name
-type
-runningTime
FIGURE 8-5
Additional 
Inheritance 
Confl icts with 
multiple Inheritance
10 Peter Coad and Edward Yourdon, Object-Oriented Design (Englewood Cliff s, NJ: Yourdon Press, 1991), p. 128.
Design Criteria  287
Purchase Order
-PO Number[1..1] : Unsigned long
-Sub Total[0..1] : Currency
-Tax[0..1] : Currency
-Shipping[0..1] : Currency
-Total[0..1] : Currency
-Customer[1..1] : Customer
-State[1..1] : State
PO1 : Purchase Order
Date : Date
PO Number : Unsigned long
Sub Total : Currency
Tax : Currency
Shipping : Currency
Total : Currency
Customer : Customer
State : State
Message1
Invoice
Object1 AcctsPayForms
-Date : Date
(a) (b)
(c)
sd Make Old Patient Appt Use Case
RequestAppt(name, address)
NewCancelChangeAppt?()
ApptTimes?()
aPatient
LookUpPatient()
aReceptionist
[aPatientExists] LookupBills()
MatchAppts()
CreateAppt()
aPatient:Patient :UnpaidBill :Appointment
FIGURE 8-6  Examples of Interaction Coupling
can cause changes to be required in other parts of the design. For object- oriented systems, Coad 
and Yourdon11 identifi ed two types of coupling to consider: interaction and inheritance.
Interaction coupling deals with the coupling among methods and objects through message 
passing. Lieberherr and Holland put forth the law of Demeter as a guideline to minimize this type 
11 Ibid.
288 Chapter 8 Class and Method Design
of coupling.12 Essentially, the law minimizes the number of objects that can receive messages from 
a given object. Th e law states that an object should send messages only to one of the following:
■ Itself (For example in Figure 8-6a, Object1 can send Message1 to itself. In other words, 
a method associated with Object1 can use other methods associated with Object1.13)
■ An object that is contained in an attribute of the object or one of its superclasses 
(For example in Figure 8-6b, the P01 instance of the Purchase Order class should 
be able to send messages using its Customer, State, and Date attributes.)
■ An object that is passed as a parameter to the method (For example in Figure 8-6c, 
the aPatient instance sends the message RequestAppt(name, address) to the aReceptionist instance, which is allowed to send messages to the instances contained in 
the name and address parameters.)
■ An object that is created by the method (For example in Figure 8-6c, the method 
RequestAppt associated with the aReceptionist instance creates an instance of the 
Appointment class. Th e RequestAppt method is allowed to send messages to that 
instance.)
■ An object that is stored in a global variable14
Even though the law of Demeter attempts to minimize interaction coupling among methods 
and objects, each of the above allowed forms of message sending in fact increases coupling. For 
example, the coupling increases between the objects if the calling method passes attributes to the 
called method or if the calling method depends on the value being returned by the called method.
Th ere are six types of interaction coupling, each falling on diff erent parts of a good-to-bad 
continuum. Th ey range from no direct coupling to content coupling. Figure 8-7 presents the 
12 Karl J. Lieberherr and Ian M. Holland, “Assuring Good Style for Object-Oriented Programs,” IEEE Soft ware 6, 
no. 5 (September, 1989): 38–48; Karl J. Lieberherr, Adaptive Object-Oriented Soft ware: Th e Demeter Method with 
Propagation Patterns (Boston, MA: PWS Publishing, 1996).
13 Obviously, this is stating what is expected.
14 From a design perspective, global variables should be avoided. Most pure object-oriented programming languages 
do not explicitly support global variables, and we do not address them any further.
FIGURE 8-7
Types of Interaction 
Coupling
Level Type Description
Good No Direct Coupling The methods do not relate to one another; that is, they do 
not call one another.
Data The calling method passes a variable to the called method. If 
the variable is composite (i.e., an object), the entire object is 
used by the called method to perform its function.
Stamp The calling method passes a composite variable (i.e., an 
object) to the called method, but the called method only 
uses a portion of the object to perform its function.
Control The calling method passes a control variable whose value 
will control the execution of the called method.
Common or Global The methods refer to a “global data area” that is outside the 
individual objects.
Bad Content or Pathological A method of one object refers to the inside (hidden parts) of 
another object. This violates the principles of encapsulation 
and information hiding. However, C++ allows this to take 
place through the use of “friends.”
Source: These types are based on material from Meilir Page-Jones, The Practical Guide to Structured 
Systems Design, 2nd Ed. (Englewood Cliffs, NJ: Yardon Press, 1988); Glenford Myers, Composite/ 
Structured Design (New York: Van Nostrand Reinhold, 1978).
Design Criteria  289
diff erent types of interaction coupling. In general, interaction coupling should be minimized. 
Th e one possible exception is that non–problem-domain classes must be coupled to their corresponding problem-domain classes. For example, a report object (on the human–computer 
interaction layer) that displays the contents of an employee object (on the problem-domain 
layer) will be dependent on the employee object. In this case, for optimization purposes, the 
report class may be even content or pathologically coupled to the employee class. However, 
problem-domain classes should never be coupled to non–problem-domain classes.
Inheritance coupling, as its name implies, deals with how tightly 
coupled the classes are in an inheritance hierarchy. Most authors tend 
to say simply that this type of coupling is desirable. However, depending 
on the issues raised previously with inheritance—inheritance confl icts, 
redefi nition capabilities, and dynamic binding—a high level of inheritance coupling might not be a good thing. For example, in Figure 8-8, 
should Method2() defi ned in Subclass be allowed to call Method1() 
defi ned in Superclass? Or, should Method2() defi ned in Subclass refer 
to Attribute1 defi ned in Superclass? Or, even more confusing, assuming 
that Superclass is an abstract class, can a Method1() call Method2() or 
use Attribute2 defi ned in Subclass? Obviously, the fi rst two examples 
have some intuitive sense. Using the properties of a superclass is the 
primary purpose of inheriting from it in the fi rst place. On the other 
hand, the third example is somewhat counterintuitive. However, owing to the way that different object-oriented programming languages support dynamic binding, polymorphism, 
and inheritance, all these examples could be possible.
As Snyder has pointed out, most problems with inheritance involve the ability 
within the object-oriented programming languages to violate the encapsulation and 
 information-hiding principles.15 From a design perspective, the developer needs to optimize the trade-off s of violating the encapsulation and information-hiding principles and 
increasing the desirable coupling between subclasses and its superclasses. Th e best way to 
solve this conundrum is to ensure that inheritance is used only to support generalization/
specialization (a-kind-of) semantics and the principle of substitutability (see Chapter 5). All 
other uses should be avoided.
Cohesion
Cohesion refers to how single-minded a module (class, object, or method) is within a system. A class or object should represent only one thing, and a method should solve only a 
single task. Th ree general types of cohesion have been identifi ed by Coad and Yourdon for 
object-oriented systems: method, class, and generalization/specialization.16
Method cohesion addresses the cohesion within an individual method (i.e., how 
single-minded a method is). Methods should do one and only one thing. A method that 
actually performs multiple functions is more diffi cult to understand—and, therefore, to 
implement and maintain—than one that performs only a single function. Seven types 
of method cohesion have been identifi ed (see Figure 8-9). Th ey range from functional 
Subclass
Superclass
+Method2()
-Attribute2
+Method1()
-Attribute1
FIGURE 8-8
Example of Inheritance Coupling
15 Alan Snyder, “Encapsulation and Inheritance in Object-Oriented Programming Languages,” in N. Meyrowitz 
(ed.), OOPSLA ’86 Conference Proceedings, ACM SigPlan Notices 21, no. 11 (November 1986); Alan Snyder, “Inheritance and the Development of Encapsulated Soft ware Components,” in B. Shriver and P. Wegner (eds.), Research 
Directions in Object-Oriented Programming (Cambridge, MA: MIT Press, 1987).
16 Coad and Yourdon, Object-Oriented Design.
290 Chapter 8 Class and Method Design
FIGURE 8-9
Types of Method 
Cohesion
Good Functional A method performs a single problem-related task (e.g., 
calculate current GPA).
Sequential The method combines two functions in which the output 
from the fi rst one is used as the input to the second one 
(e.g., format and validate current GPA).
Communicational The method combines two functions that use the same 
attributes to execute (e.g., calculate current and cumulative GPA).
Procedural The method supports multiple weakly related functions. 
For example, the method could calculate student GPA, 
print student record, calculate cumulative GPA, and print 
cumulative GPA.
Temporal or Classical The method supports multiple related functions in time 
(e.g., initialize all attributes).
Logical The method supports multiple related functions, but the 
choice of the specifi c function is chosen based on a control variable that is passed into the method. For example, 
the called method could open a checking account, open 
a savings account, or calculate a loan, depending on the 
message that is sent by its calling method.
Bad Coincidental The purpose of the method cannot be defi ned or it 
performs multiple functions that are unrelated to one 
another. For example, the method could update customer 
records, calculate loan payments, print exception reports, 
and analyze competitor pricing structure.
Source: These types are based on material from Page-Jones, The Practical Guide to Structured Systems; Myers, Composite/Structured Design; Edward Yourdon and Larry L. Constantine, Structured 
Design: Fundamentals of a Discipline of Computer Program and Systems Design (Englewood Cliffs, NJ: 
Prentice-Hall, 1979).
 Level Type Description
 cohesion (good) down to coincidental cohesion (bad). In general, method cohesion 
should be maximized.
Class cohesion is the level of cohesion among the attributes and methods of a class 
(i.e., how single-minded a class is). A class should represent only one thing, such as an 
employee, a department, or an order. All attributes and methods contained in a class should 
be required for the class to represent the thing. For example, an employee class should 
have attributes that deal with a social security number, last name, fi rst name, middle initial, 
addresses, and benefi ts, but it should not have attributes such as door, engine, or hood. 
Furthermore, there should be no attributes or methods that are never used. In other words, a 
class should have only the attributes and methods necessary to fully defi ne instances for the 
problem at hand. In this case, we have ideal class cohesion. Glenford Meyers suggested that a 
cohesive class17 should have these attributes:
■ It should contain multiple methods that are visible outside the class (i.e., a 
 single-method class rarely makes sense).
■ Each visible method performs only a single function (i.e., it has functional cohesion; 
see Figure 8-9).
17 We have adapted his informational-strength module criteria from structured design to object-oriented design. [See 
Glenford J. Myers, Composite/Structured Design (New York, NY: Van Nostrand Reinhold, 1978).]
Design Criteria  291
FIGURE 8-10
Types of Class 
Cohesion
Good Ideal The class has none of the mixed cohesions.
Mixed-Role The class has one or more attributes that relate objects 
of the class to other objects on the same layer (e.g., the 
problem domain layer), but the attribute(s) has nothing to 
do with the underlying semantics of the class.
Mixed-Domain The class has one or more attributes that relate objects of 
the class to other objects on a different layer. As such, they 
have nothing to do with the underlying semantics of the 
thing that the class represents. In these cases, the offending 
attribute(s) belongs in another class located on one of the 
other layers. For example, a port attribute located in a problem domain class should be in a system architecture class 
that is related to the problem domain class.
Worse Mixed-Instance The class represents two different types of objects. The class 
should be decomposed into two separate classes. Typically, 
different instances only use a portion of the full defi nition 
of the class.
Based upon material from Page-Jones, Fundamentals of Object-Oriented Design in UML.
 Level Type Description
■ All methods reference only attributes or other methods defi ned within the 
class or one of its superclasses (i.e., if a method is going to send a message to 
another object, the remote object must be the value of one of the local object’s 
attributes).18
■ It should not have any control couplings between its visible methods (see Figure 8-7).
Page-Jones19 has identifi ed three less-than-desirable types of class cohesion: mixed-instance, 
mixed-domain, and mixed-role (see Figure 8-10). An individual class can have a mixture of 
any of the three types.
Generalization/specialization cohesion addresses the sensibility of the inheritance hierarchy. How are the classes in the inheritance hierarchy related? Are the classes related through a 
generalization/specialization (a-kind-of) semantics? Or, are they related via some association, 
aggregation, or membership type of relationship that was created for simple reuse purposes? 
Recall all the issues raised previously on the use of inheritance. For example, in Figure 8-11, 
the subclasses ClassRooms and Staff inherit from the superclass Department. Obviously, 
instances of the ClassRooms and Staff classes are not a-kind-of Department. However, in the 
early days of object-oriented programming, this use of inheritance was quite common. When 
a programmer saw that there were some common properties that a set of classes shared, the 
programmer would create an artifi cial abstraction that defi ned the commonalities. Th is was 
potentially useful in a reuse sense, but it turned out to cause many maintenance nightmares. 
In this case, instances of the ClassRooms and Staff classes are associated with or a-part-of an 
instance of Department. Today we know that highly cohesive inheritance hierarchies should 
support only the semantics of generalization and specialization (a-kind-of) and the principle 
of substitutability.
18 Th is restricts messages passing to only the fi rst, second, and fourth conditions supported by the law of Demeter. 
For example, in Figure 8-6c, aReceptionist must have attributes associated with it that contains objects for Patients, 
Unpaid Bills, and Appointments. Furthermore, once an instance of Appointment is created, aReceptionist must have 
an attribute with the instance as its value to send any additional messages.
19 See Meilir Page-Jones, Fundamentals of Object-Oriented Design in UML (Reading, MA: Addison-Wesley, 2000).
292 Chapter 8 Class and Method Design
Connascence
Connascence20 generalizes the ideas of cohesion and coupling, and it combines them with 
the arguments for encapsulation. To accomplish this, three levels of encapsulation have been 
identifi ed. Level-0 encapsulation refers to the amount of encapsulation realized in an individual line of code, level-1 encapsulation is the level of encapsulation attained by combining lines 
of code into a method, and level-2 encapsulation is achieved by creating classes that contain 
both methods and attributes. Method cohesion and interaction coupling address primarily 
level-1 encapsulation. Class cohesion, generalization/specialization cohesion, and inheritance 
coupling address only level-2 encapsulation. Connascence, as a generalization of cohesion 
and coupling, addresses both level-1 and level-2 encapsulation.
But what exactly is connascence? Connascence literally means to be born together. From 
an object-oriented design perspective, it really means that two modules (classes or methods) 
are so intertwined that if you make a change in one, it is likely that a change in the other will 
be required. On the surface, this is very similar to coupling and, as such, should be minimized. 
However, when you combine it with the encapsulation levels, it is not quite that simple. In 
this case, we want to minimize overall connascence by eliminating any unnecessary connascence throughout the system; minimize connascence across any encapsulation boundaries, 
such as method boundaries and class boundaries; and maximize connascence within any 
encapsulation boundary.
Based on these guidelines, a subclass should never directly access any hidden attribute 
or method of a superclass [i.e., a subclass should not have special rights to the properties 
of its superclass(es)]. If direct access to the nonvisible attributes and methods of a superclass by its subclass is allowed—and is permitted in most object-oriented programming 
languages—and a modifi cation to the superclass is made, then owing to the connascence 
between the subclass and its superclass, it is likely that a modifi cation to the subclass also 
is required.21 In other words, the subclass has access to something across an encapsulation 
boundary (the class boundary between the subclass and the superclass). Practically speaking, you should maximize the cohesion (connascence) within an encapsulation boundary 
and minimize the coupling (connascence) between the encapsulation boundaries. Th ere are 
many possible types of connascence. Figure 8-12 describes fi ve of the types.
Department
ClassRooms Staff FIGURE 8-11
Generalization/
Specialization vs. 
Inheritance Abuse
20 See Meilir Page-Jones, “Comparing Techniques by Means of Encapsulation and Connascence,” Communications 
of the ACM 35, no. 9 (September 1992): 147–151.
21 Based on these guidelines, the use of the protected visibility, as supported in Java and C11, should be minimized, 
if not avoided. “Friends” as defi ned in C11 also should be minimized or avoided. Owing to the level of dependencies 
these language features create, any convenience aff orded to a programmer is more than off set in potential design, 
understandability, and maintenance problems. Th ese features must be used with great caution and must be fully
